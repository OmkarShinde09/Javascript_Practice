<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced functions</title>
</head>
<body>

    <button class="js-button" onclick="">Click</button>

    <script>
        /*
        const buttonElement = document.querySelector('.js-button');

        const eventListener = () => {
            console.log('click');
        }
        buttonElement.addEventListener('click', eventListener);//Instead of onclick attribute we can use addEventListener which gives us advantages like 1.Multiple event listeners for an event. 2.We can remove an event listener by .removeEventListener()

        buttonElement.removeEventListener('click', eventListener);

        buttonElement.addEventListener('click', () => {
            console.log('click2');
        });
        */

        /*
        function greeting(){
                console.log('hello');
            }
            greeting();//This is called calling a function

            const num = 2;//num variable is a value
            const function1 = function greeting(){
                console.log('hello2');
            };

            // //This is an anonymous function. The natural way in which we write function is a shortcut. It is 1. Easier to read. 2. Hoisting : We can call a function before it is declared in a code.
            // const function1 = function(){
            //     console.log('hello2');
            // };


            console.log(function1);
            console.log(typeof function1);//We see that function is just another type of a

            const object1 = {
                num : 2,
                fun : function(){
                    console.log('hello3');
                }
            };
            object1.fun();

            function display(param){
                console.log(param);
            }
            display(2);


            function run(param){
                param();
            }
            run(function(){
                    console.log('hello4');
                }
            );//Passing a function as parameter in another function. Passed function is called callback function.
            */

        /*
        setTimeout(function(){
            console.log('timeout');
        }, 3000);//This is an inbuilt function which has two parameters. In this example the function is called after 3 seconds.

        console.log('next line');//This gets printed before setTimeout function because it has a starting time of 3seconds. This is called Asynchronous Code wherein the computer won't wait for one line to finish if it has a timer. It will just start the timer. Till now we have used Synchronous code.

        setInterval(function(){
            console.log('interval')
        }, 3000);//This will run the function every 3 seconds.


        [
            'make dinner',
            'wash dishes', 
            'watch youtube'
        ].forEach(function(value, index){
            if(value === 'wash dishes'){
                return;
            }
            console.log(index);
            console.log(value);
        });//This method allows us to loop through the array. It is actually the preferred method to loop through the array because it is easier to read.


        const arrowFunction = () => {
            console.log('hello');
        };
        arrowFunction();//This is an arrowfunction.
        const oneParam = (param) => {
            console.log(param + 1);
        };//When there is only one parameter present you can skip the () paranthesis in the function declaration.
        oneParam(2);

        const oneLine = () => 2 + 3; //This is a one line arrow function.
        console.log(oneLine());

        [
            'make dinner',
            'wash dishes', 
            'watch youtube'
        ].forEach((value, index) =>{
            if(value === 'wash dishes'){
                return;
            }
            console.log(index);
            console.log(value);
        });//It is easier to write and read arrowfunction in a foreach loop instead.

        const object2 = {
            method: () => {

            },
            method(){

            }//Both of the above syntax give the same result but the second one is shorter and easier to read.
        }
        */

        [1, -3, 5].filter((value, index) => {
            // return true;//This filter returns boolean values.
            if(value >= 0){
                return true;//If true then include elements in the array.
            }
            else{
                return false;
            }
        });//filter removes the negative values. It works the same way as forEach.

        // [1, 1, 3].map((value, index) => {
        //     // return value + 10;//What map does is it creates a new array and whatever we return it adds to new array.
        // });

        console.log([1, 1, 3].map(value => value + 10));//This code does the same thing as above but in a more compact way.
        
        //Closure: If a function has access to a value, it will always have access to that value.
    </script>
</body>
</html>